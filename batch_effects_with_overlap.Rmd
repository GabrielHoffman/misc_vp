---
title: "Simulation analysis of batching in RNA-seq"
subtitle: ''
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{Gene set enrichment from genomic intervals}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---


<!---

cd /hpc/users/hoffmg01/work/misc_vp
ml git pandoc
git pull
R


rmarkdown::render("batch_effects_with_overlap.Rmd", output_dir='./', intermediates_dir='./')


# ```{r}
# knitr::knit_exit()
# ```


--->


## TODO

- write code to add time point
- sim fewer reads for shared controls
- what happens if shared is only controls and they are very different
- disease effect is time point dependent
- number of shared controls


Combine study design with statistical modelling to account for batch effects

- Naive: no redundant samples and ignore batch effect
- Simple: no redundant samples, account for batch effect by setting the mean of each batch to be equal for each gene. 
- Replicates: include a set of samples in multiple batches
	- Perform differential expression *jointly* modeling batch, disease, and individual replicates
	- Two step: statistically estimate the expression profile for each individual considering batches and replicates.  This method is ideal because it estimates the corrected expression profile and can be used downstream
- In this simulation experiment, I also include the "oracle" scenerio where the batch correction is performed exactly as if provided by an oracle.


is time point really within batch?
are we interested in case control or timepoint comparison?


```{r load.packages, echo=FALSE, message=FALSE, results='hide'}
suppressPackageStartupMessages({
library(variancePartition)
library(PRROC)
library(BiocParallel)
register(SerialParam())
library(lme4)
library(BiocParallel)
library(gridExtra)
})

set.seed(1)
register(SnowParam(4))

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = FALSE,
  cache.lazy = FALSE,  dev = c("png", "pdf"), 
  fig.width=7, fig.height=7)

options(markdown.HTML.stylesheet = 'css/custom.css')
```

```{r}
# convert mean and variances in parameters of beta distribution
# https://en.wikipedia.org/wiki/Beta_distribution#Parameter_estimation
# there is a limit on the variance given constraints of the beta distribution.
# If var exceeds this limit, assign maximum allows variance
estimate_beta_parameters = function(mu, v){
	v = min(v, 0.8*mu*(1-mu))

	alpha = mu*(mu*(1-mu)/v - 1)
	beta = (1-mu) *(mu*(1-mu)/v - 1)

	c(alpha=alpha, beta=beta)
}

# Given an expression matrix Y with genes in rows, 
# get mean expression for each individual
mean_per_sampleID = function(Y1, info){

	sid_array = as.character(unique(info$SampleID))
	M = lapply(sid_array, function(SID){
		idx = info[info$SampleID == SID,'idx']
		i = colnames(Y1) %in% as.character(idx)
		m = rowMeans(Y1[,i,drop=FALSE])
		as.matrix(m)
		} )
	M = do.call(cbind, M)
	colnames(M) = sid_array
	M
}
```


```{r define.simulation.function}

generateSimulations = function( opt, info ){

	attach(opt)

	# create design matrix for each variable
	design_ID = model.matrix( ~ 0+Individual,info)
	design_Disease = model.matrix( ~ 0+Disease,info)
	design_TimePoint = model.matrix( ~ 0+TimePoint,info)[,-3] # don't simulate additional difference between controls (tp0) and cases
	design_Batch = model.matrix( ~ 0+Batch,info)

	# get names of differentially expressed genes
	deGenes = paste0("gene_", 1:n_de)
	tpGenes = paste0("gene_", sample.int( p, n_tp))

	# Simulate expression data
	simResults = lapply( 1:p, function(j){

		# Individual
		eta_ID = design_ID %*% rnorm(nlevels(info$Individual))

		# Batch
		eta_batch = design_Batch %*% rnorm(nlevels(info$Batch))

		# TimePoint
		eta_TimePoint = design_TimePoint %*% rnorm(nlevels(info$TimePoint)-1)

		# draw variance fractions
		sigSq_ID = rbeta(1, opt$distr_ID[1], opt$distr_ID[2])
		sigSq_Batch = rbeta(1, opt$distr_Batch[1], opt$distr_Batch[2])
		sigSq_TimePoint = rbeta(1, opt$distr_Timepoint[1], opt$distr_Timepoint[2])

		if( ! paste0('gene_', j) %in% tpGenes ){
			sigSq_TimePoint = 0
		}

		# of each sample is observed once, no donor component
		if(  max(table(info$Individual)) == 1){
			sigSq_ID = 1e-4
		}

		# each individual has its own error variance
		v_var = rbeta( nlevels(info$Individual), 1, 1) + 0.5
		resid_var = model.matrix( ~ 0+Individual, info) %*% v_var

		if( j <= n_de){
			# Disease
			eta_Disease = design_Disease %*% rnorm(nlevels(info$Disease))

			sigSq_Disease = rbeta(1, opt$distr_Disease[1], opt$distr_Disease[2])
			sigSq_Resid = max(1 - sigSq_ID - sigSq_Disease - sigSq_Batch - sigSq_TimePoint, .05)

			# combine
			y = scale(eta_ID) * (sigSq_ID-sigSq_Disease) + 
				scale(eta_batch) * sigSq_Batch + 
				scale(eta_Disease) * sigSq_Disease +	
				scale(eta_TimePoint) * sigSq_TimePoint +			 
				rnorm(nrow(info), 0, sd=sqrt(resid_var)) * sigSq_Resid
		}else{
			sigSq_Resid = max(1 - sigSq_ID - sigSq_Batch - sigSq_TimePoint, .05)

			# combine
			y = scale(eta_ID) * sigSq_ID + 
				scale(eta_batch) * sigSq_Batch + 	
				scale(eta_TimePoint) * sigSq_TimePoint +	 
				rnorm(nrow(info), sd=sqrt(resid_var)) * sigSq_Resid
		}
		
		y_clean = y - scale(eta_batch) * sigSq_Batch

		list(y = t(y),
			y_clean = t(y_clean))
	})

	# observed expression data
	Y = do.call(rbind, lapply(simResults, function(x) x$y))
	rownames(Y) = paste0("gene_", 1:nrow(Y))

	# Oracle, with *perfect* batch correction
	Y_oracle = do.call(rbind, lapply(simResults, function(x) x$y_clean))
	rownames(Y_oracle) = paste0("gene_", 1:nrow(Y_oracle))

	# Get metadata at the individal level.  info is at the experiment level
	metadata = unique(with(info, data.frame(Individual, TimePoint, Disease, stringsAsFactors=FALSE)))
	rownames(metadata) = with(metadata, paste(Individual, TimePoint, sep=':'))
	metadata$Batch = "batch1"

	unique_ID_idx = !duplicated(info$SampleID)

	list(	Y 				= Y,
			Y_oracle 		= Y_oracle,
			metadata		= metadata,
			unique_ID_idx 	= unique_ID_idx,
			deGenes			= deGenes,
			tpGenes			= tpGenes)
}
```

```{r simulation.params, fig.width=12, fig.height=4}

opt = list()

opt$n_cases = 100 # total number of individuals
opt$n_control = 10 # number of control individuals
opt$n_time_points = 2
# total number of experiments: N*n_time_points
opt$p = 400
opt$n_de = 100 # genes different between case and control
opt$n_tp = 100 # genes different between time points
opt$n_samples_per_batch = 20
opt$n_batches = opt$n_cases*opt$n_time_points / opt$n_samples_per_batch
opt$n_batches

# n_batches_per_timePoint = n_cases / n_samples_per_batch


opt$distr_ID = estimate_beta_parameters( .3, .01)
opt$distr_Disease = estimate_beta_parameters( .2, .05)
opt$distr_Timepoint = estimate_beta_parameters( .3, .1)
opt$distr_Batch = estimate_beta_parameters( .3, .05)

# Generate study design
info = data.frame(	Individual = rep(paste0("ID", 1:opt$n_cases), opt$n_time_points),
					TimePoint = unlist(lapply(1:opt$n_time_points, function(x) rep(paste0("time", x), opt$n_cases))),
					Disease = "Case", 
				stringsAsFactors=FALSE)

# For a given probability of being in each batch
# all equal
# prob = rbind(	rep(1/n_batches, n_batches),
# 				rep(1/n_batches, n_batches))

shifter <- function(x, n = 1) {
  if (n == 0) x else c(tail(x, -n), head(x, n))
}
alpha = 2
x = sort((1:opt$n_batches)^alpha, decreasing=TRUE)

# x = c(.5, .5,  0, 0)
prob = rbind(x, rev(x))
prob = prob / rowSums(prob)
rownames(prob) = paste0("time", 1:nrow(prob))
colnames(prob) = paste0("batch", 1:ncol(prob))

info$Batch = NA
for( tp in unique(info$TimePoint) ){
	i = which(info$TimePoint == tp)
	info$Batch[i] = paste0("batch", sample.int(opt$n_batches, length(i), replace=TRUE, prob[tp,]))
}
table(info$Batch)



# add a set of shared controls to each batch
infoControl.tmp = data.frame( Individual = paste0("ID", (opt$n_cases+1):(opt$n_cases+opt$n_control)),
	TimePoint = "time0",
	Disease = "control", stringsAsFactors=FALSE)

infoControl = c()
for( batch in unique(info$Batch) ){
	infoControl.tmp$Batch = batch
	infoControl = rbind(infoControl, infoControl.tmp)
}

# combine cases and controls
info = rbind(info, infoControl)

info$SampleID = with(info, paste(Individual, TimePoint, sep=':'))
info$idx = 1:nrow(info)

# set as factors
info$Individual = factor(info$Individual, unique(info$Individual))
info$Disease = factor(info$Disease)
info$Batch = factor(info$Batch, colnames(prob))
info$TimePoint = factor(info$TimePoint, unique(info$TimePoint))

# plot study design
ratio = with(info, length(unique(Batch))/ length(unique(Individual)) )
ggplot(info, aes(Individual, fill=TimePoint, y=Batch)) + geom_tile() + theme_bw() + theme(aspect.ratio=ratio, legend.position="bottom", plot.title = element_text(hjust = 0.5), axis.text.x=element_blank()) + ggtitle("Sample batching")
```


```{r run.simulation}

simObj = generateSimulations( opt, info )

attach(simObj)
```

# VariancePartition results
```{r variancePartition, fig.width=12}
# fit variancePartition model
vp = fitExtractVarPartModel( Y, ~ (1|TimePoint) + (1|Disease) + (1|Batch) + (1|Individual), info)
fig1 = plotVarPart( vp ) + ggtitle("Observed data")

# fit variancePartition model on clean data with no batch effect
vp_oracle = fitExtractVarPartModel( Y_oracle, ~ (1|TimePoint) + (1|Disease) + (1|Batch) + (1|Individual), info)
fig2 = plotVarPart( vp_oracle ) + ggtitle("Oracle")

grid.arrange(fig1, fig2, ncol=2)
```

```{r batch.correction}

Y_list = list()

fitList = fitVarPartModel( Y, ~ (1|Batch) + (1|TimePoint) + (1|Disease) + (1|Individual) , info, fxn = function(fit){ 
		# B = predict(fit, metadata[,c("Batch"),drop=FALSE], re.form=~(1|Batch))
		# fit@resp$y[unique_ID_idx] - B	
		B = predict(fit, info[,c("Batch"),drop=FALSE], re.form=~(1|Batch))
		fit@resp$y - B
	}, showWarnings=FALSE, BPPARAM=SerialParam())

Y_corrected = do.call(rbind, fitList)
rownames(Y_corrected) = rownames(Y)
Y_list[["remove_batch_full_model"]] = Y_corrected

Y_list[["remove_batch_simple"]] = removeBatchEffect(Y, info$Batch, design=model.matrix(~TimePoint + Disease, info))


```



# PCA using multiple types of corrections
```{r pca, fig.width=8, fig.height=8}
# Plot coloring by individual
par(mfrow=c(2,2), pty='s')
# PCA of data with no batch effect
dcmp = prcomp( t(Y_oracle), scale=TRUE)
plot(dcmp$x[,1:2], col=info$TimePoint, pch=as.integer(info$Disease)+6, main="Oracle")

# PCA of original data
dcmp = prcomp( t(Y), scale=TRUE)
plot(dcmp$x[,1:2], col=info$TimePoint, pch=as.integer(info$Disease)+6, main="Observed data")

dcmp = prcomp( t(Y_list[["remove_batch_full_model"]]), scale=TRUE)
plot(dcmp$x[,1:2], col=info$TimePoint, pch=as.integer(info$Disease)+6, main="Full model of replicates")

dcmp = prcomp( t(Y_list[["remove_batch_simple"]]), scale=TRUE)
plot(dcmp$x[,1:2], col=info$TimePoint, pch=as.integer(info$Disease)+6, main="Simple batch correction")
```




Oracle DE should only observe each control once, does that matter?

```{r differential.expression}

fitList = list()
idx = match(colnames(Y_oracle), info$idx)
fitList[['Oracle']] = dream(Y_oracle, ~ (1|Disease) + TimePoint + (1|Individual), info[idx,])

idx = match(colnames(Y), info$idx)
fitList[['Replicates - joint model']] = dream(Y, ~ (1|Disease) + (1|Batch) + TimePoint + (1|Individual), info[idx,])

fitList[['Replicates: Two step']] = dream(Y_list[["remove_batch_full_model"]], ~ (1|Disease) + TimePoint + (1|Individual), info)

idx = (! duplicated(info$SampleID)) & (info$Disease == "Case")
fitList[['No controls, no replicates, ignore batch']] = dream(Y[,idx], ~ TimePoint + (1|Individual), info[idx,])

tryCatch({
idx = which(info$Disease == "Case")
fitList[['No controls, no replicates']] = dream(Y[,idx], ~ (1|Batch) + TimePoint + (1|Individual), info[idx,])
}, error = function(e) print("eRROR!"))

res = lapply(names(fitList), function(method){

	tab = topTable(fitList[[method]], coef="TimePointtime2", number=Inf, sort.by="none")

	# add missing genes to tab with P.Value = 1
	excluded = which(!rownames(Y) %in% rownames(tab))

	if( length(excluded) > 0){
		tab_excluded = tab[1:length(excluded),]
		rownames(tab_excluded) = rownames(Y)[excluded]
		tab_excluded[] = NA
		tab_excluded$P.Value = 1
		tab = rbind(tab, tab_excluded)
	}

	idx = rownames(tab) %in% tpGenes

	pr <- pr.curve( -log10(tab$P.Value[idx]), -log10(tab$P.Value[!idx]), curve=TRUE, rand.compute=TRUE )

	data.frame( method 		= method, 
				AUPR 		= pr$auc.integral, 
				AUPR.random = pr$rand$auc.integral,
				stringsAsFactors=FALSE)
	})
res = do.call(rbind, res)

ord = c('No controls, no replicates, ignore batch',
		'No controls, no replicates',
		'Replicates: Two step',
		'Replicates - joint model',
		'Oracle') 
 
# res$method[!res$method %in% ord]

# "Replicates: set batch mean equal",
res$method = factor(res$method, ord)

ggplot(res, aes(method, AUPR, fill=method)) + geom_bar(stat="identity") + theme_bw() + theme(aspect.ratio=1, plot.title = element_text(hjust = 0.5), legend.position="none") + xlab("Method") + scale_y_continuous(limits=c(0, 1.02), expand=c(0, 0)) + geom_hline(yintercept = res$AUPR.random[1], linetype="dashed") + coord_flip() 

```








