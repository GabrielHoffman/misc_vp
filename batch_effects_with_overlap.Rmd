---
title: "Simulation analysis of batching in RNA-seq"
subtitle: ''
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
vignette: >
  %\VignetteIndexEntry{Gene set enrichment from genomic intervals}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\usepackage[utf8]{inputenc}
---


<!---

cd /hpc/users/hoffmg01/work/misc_vp
ml git pandoc
git pull
R


rmarkdown::render("batch_effects_with_overlap.Rmd", output_dir='./', intermediates_dir='./')


# ```{r}
# knitr::knit_exit()
# ```


--->


## TODO

- write code to add time point
- sim fewer reads for shared controls
- what happens if shared is only controls and they are very different
- disease effect is time point dependent
- number of shared controls


Combine study design with statistical modelling to account for batch effects

- Naive: no redundant samples and ignore batch effect
- Simple: no redundant samples, account for batch effect by setting the mean of each batch to be equal for each gene. 
- Replicates: include a set of samples in multiple batches
	- Perform differential expression *jointly* modeling batch, disease, and individual replicates
	- Two step: statistically estimate the expression profile for each individual considering batches and replicates.  This method is ideal because it estimates the corrected expression profile and can be used downstream
- In this simulation experiment, I also include the "oracle" scenerio where the batch correction is performed exactly as if provided by an oracle.


is time point really within batch?
are we interested in case control or timepoint comparison?


```{r load.packages, echo=FALSE, message=FALSE, results='hide'}
suppressPackageStartupMessages({
library(variancePartition)
library(PRROC)
library(BiocParallel)
library(lme4)
library(gridExtra)
})

set.seed(1)
register(SnowParam(4))

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE,
  cache.lazy = FALSE,  dev = c("png", "pdf"), 
  fig.width=7, fig.height=7)

options(markdown.HTML.stylesheet = 'css/custom.css')
```

```{r}
# convert mean and variances in parameters of beta distribution
# https://en.wikipedia.org/wiki/Beta_distribution#Parameter_estimation
# there is a limit on the variance given constraints of the beta distribution.
# If var exceeds this limit, assign maximum allows variance
estimate_beta_parameters = function(mu, v){
	v = min(v, 0.8*mu*(1-mu))

	alpha = mu*(mu*(1-mu)/v - 1)
	beta = (1-mu) *(mu*(1-mu)/v - 1)

	c(alpha=alpha, beta=beta)
}

# Given an expression matrix Y with genes in rows, 
# get mean expression for each individual
mean_per_sampleID = function(Y1, info){

	sid_array = as.character(unique(info$SampleID))
	M = lapply(sid_array, function(SID){
		idx = info[info$SampleID == SID,'idx']
		i = colnames(Y1) %in% as.character(idx)
		m = rowMeans(Y1[,i,drop=FALSE])
		as.matrix(m)
		} )
	M = do.call(cbind, M)
	colnames(M) = sid_array
	M
}
```


```{r define.simulation.functions}

generateSimulations = function( opt, info ){

	# create design matrix for each variable
	design_ID = model.matrix( ~ 0+Individual,info)
	design_Disease = model.matrix( ~ 0+Disease,info)
	design_TimePoint = model.matrix( ~ 0+TimePoint,info)
	design_Batch = model.matrix( ~ 0+Batch,info)

	# Simulate expression data
	simResults = lapply( 1:opt$p, function(j){

		# Individual
		eta_ID = design_ID %*% rnorm(nlevels(info$Individual))

		# Batch
		eta_batch = design_Batch %*% rnorm(nlevels(info$Batch))

		# TimePoint
		eta_TimePoint = design_TimePoint %*% rnorm(nlevels(info$TimePoint))

		# draw variance fractions
		sigSq_ID = rbeta(1, opt$distr_ID[1], opt$distr_ID[2])
		sigSq_Batch = rbeta(1, opt$distr_Batch[1], opt$distr_Batch[2])
		sigSq_TimePoint = rbeta(1, opt$distr_Timepoint[1], opt$distr_Timepoint[2])

		if( ! paste0('gene_', j) %in% opt$tpGenes ){
			sigSq_TimePoint = 0
		}

		# of each sample is observed once, no donor component
		if(  max(table(info$Individual)) == 1){
			sigSq_ID = 1e-4
		}

		# each individual has its own error variance
		v_var = rbeta( nlevels(info$Individual), 1, 1) + 0.5
		resid_var = model.matrix( ~ 0+Individual, info) %*% v_var

		if( paste0('gene_', j) %in% opt$deGenes ){
			# Disease
			eta_Disease = design_Disease %*% rnorm(nlevels(info$Disease))

			sigSq_Disease = rbeta(1, opt$distr_Disease[1], opt$distr_Disease[2])
			sigSq_Resid = max(1 - sigSq_ID - sigSq_Disease - sigSq_Batch - sigSq_TimePoint, .05)

			# combine
			y = scale(eta_ID) * (sigSq_ID-sigSq_Disease) + 
				scale(eta_batch) * sigSq_Batch + 
				scale(eta_Disease) * sigSq_Disease +	
				scale(eta_TimePoint) * sigSq_TimePoint +			 
				rnorm(nrow(info), 0, sd=sqrt(resid_var)) * sigSq_Resid
		}else{
			sigSq_Resid = max(1 - sigSq_ID - sigSq_Batch - sigSq_TimePoint, .05)

			# combine
			y = scale(eta_ID) * sigSq_ID + 
				scale(eta_batch) * sigSq_Batch + 	
				scale(eta_TimePoint) * sigSq_TimePoint +	 
				rnorm(nrow(info), sd=sqrt(resid_var)) * sigSq_Resid
		}
		
		# Perfect correction for batch
		y_oracle = y - scale(eta_batch) * sigSq_Batch

		list(	y 		= t(y),
				y_oracle = t(y_oracle))
	})

	# observed expression data
	Y = do.call(rbind, lapply(simResults, function(x) x$y))
	rownames(Y) = paste0("gene_", 1:nrow(Y))

	# Oracle, with *perfect* batch correction
	Y_oracle = do.call(rbind, lapply(simResults, function(x) x$y_oracle))
	rownames(Y_oracle) = paste0("gene_", 1:nrow(Y_oracle))

	# Get metadata at the individal level.  info is at the experiment level
	metadata = unique(with(info, data.frame(Individual, TimePoint, Disease, stringsAsFactors=FALSE)))
	rownames(metadata) = with(metadata, paste(Individual, TimePoint, sep=':'))
	metadata$Batch = "batch1"

	unique_ID_idx = !duplicated(info$SampleID)

	list(	Y 				= Y,
			Y_oracle 		= Y_oracle,
			metadata		= metadata,
			unique_ID_idx 	= unique_ID_idx,
			deGenes			= opt$deGenes,
			tpGenes			= opt$tpGenes)
}


createInfo = function( opt ){

	# Generate study design
	info = data.frame(	Individual = rep(paste0("ID", 1:opt$n_cases), opt$n_time_points),
						TimePoint = unlist(lapply(1:opt$n_time_points, function(x) rep(paste0("time", x), opt$n_cases))),
						Disease = "Case", 
					stringsAsFactors=FALSE)

	prob = rbind(opt$prob, rev(opt$prob))
	prob = prob / rowSums(prob)
	rownames(prob) = paste0("time", 1:nrow(prob))
	colnames(prob) = paste0("batch", 1:ncol(prob))

	info$Batch = NA
	for( tp in unique(info$TimePoint) ){
		i = which(info$TimePoint == tp)
		info$Batch[i] = paste0("batch", sample.int(opt$n_batches, length(i), replace=TRUE, prob[tp,]))
	}
	table(info$Batch)


	# add a set of shared controls to each batch
	infoControl.tmp = data.frame( Individual = paste0("ID", (opt$n_cases+1):(opt$n_cases+opt$n_control)),
		TimePoint = "time1",
		Disease = "control", stringsAsFactors=FALSE)

	infoControl = c()
	for( batch in unique(info$Batch) ){
		infoControl.tmp$Batch = batch
		infoControl = rbind(infoControl, infoControl.tmp)
	}

	# combine cases and controls
	info = rbind(info, infoControl)

	info$SampleID = with(info, paste(Individual, TimePoint, sep=':'))
	info$idx = 1:nrow(info)

	info$Status = with(info, paste(Disease, TimePoint, sep=' - '))

	# set as factors
	info$Individual = factor(info$Individual, unique(info$Individual))
	info$Disease = factor(info$Disease)
	info$Batch = factor(info$Batch, colnames(prob))
	info$TimePoint = factor(info$TimePoint, unique(info$TimePoint))
	info$Status = factor(info$Status)

	info
}

plotStudyDesign = function(info){
	# plot study design
	ratio = with(info, length(unique(Batch))/ length(unique(Individual)) )
	ggplot(info, aes(Individual, fill=Status, y=Batch)) + geom_tile() + theme_bw() + theme(aspect.ratio=ratio, legend.position="bottom", plot.title = element_text(hjust = 0.5), axis.text.x=element_blank()) + ggtitle("Sample batching")
}


evalBatchCorrection = function( simObj, info ){
	
	Y = simObj$Y

	Y_list = list()

	# This gave a strange error in multithreaded mode
	fitList = fitVarPartModel( Y, ~ (1|Batch) + (1|TimePoint) + (1|Disease) + (1|Individual), info, fxn = function(fit){ 
			B = predict(fit, info[,c("Batch"),drop=FALSE], re.form=~(1|Batch))
			fit@resp$y - B
		}, showWarnings=FALSE, BPPARAM=SerialParam())

	Y_corrected = do.call(rbind, fitList)
	rownames(Y_corrected) = rownames(Y)
	Y_list[["remove_batch_full_model"]] = Y_corrected

	Y_list[["remove_batch_simple"]] = removeBatchEffect(Y, info$Batch, design=model.matrix(~TimePoint, info))

	Y_list
}


evalDifferentialExpression = function(simObj, info, corrRetain=1){

	Y = simObj$Y
	Y_oracle = simObj$Y_oracle

	fitList = list()
	idx = match(colnames(Y_oracle), info$idx)
	fitList[['Oracle']] = dream(Y_oracle, ~ (1|Disease) + TimePoint + (1|Individual), info[idx,])

	fitList[['Replicates - joint model']] = dream(Y, ~ (1|Disease) + (1|Batch) + TimePoint + (1|Individual), info)

	# add noise just to controls
	# construct so that cor(Y[j,], Y_noise[j,])^2 = corrRetain
	Y_noise = Y
	idx = which(info$Disease == "control")
	for(j in 1:nrow(Y) ){
		y = Y_noise[j,idx]
		Y_noise[j,idx] = y + rnorm(length(y), 0, sd=sqrt(var(y)*(1-corrRetain)/corrRetain)) 
	}
	# j=10
	# cor(Y[j,idx], Y_noise[j,idx])^2
	# corrRetain

	fitList[['Replicates - joint model + noiseToControls']] = dream(Y_noise, ~ (1|Disease) + (1|Batch) + TimePoint + (1|Individual), info)

	fitList[['Replicates: Two step']] = dream(Y_list[["remove_batch_full_model"]], ~ (1|Disease) + TimePoint + (1|Individual), info)

	idx = (! duplicated(info$SampleID)) & (info$Disease == "Case")
	fitList[['Naive: No controls, no replicates, ignore batch']] = dream(Y[,idx], ~ TimePoint + (1|Individual), info[idx,])

	idx = which(info$Disease == "Case")
	fitList[['Simple: No controls, no replicates']] = dream(Y[,idx], ~ (1|Batch) + TimePoint + (1|Individual), info[idx,])
	
	fitList
}


evalPerformance = function( fitList, coef, positives){

	res = lapply(names(fitList), function(method){

		tab = topTable(fitList[[method]], coef=coef, number=Inf, sort.by="none")

		# add missing genes to tab with P.Value = 1
		# excluded = which(!rownames(Y) %in% rownames(tab))

		# if( length(excluded) > 0){
		# 	tab_excluded = tab[1:length(excluded),]
		# 	rownames(tab_excluded) = rownames(Y)[excluded]
		# 	tab_excluded[] = NA
		# 	tab_excluded$P.Value = 1
		# 	tab = rbind(tab, tab_excluded)
		# }

		idx = rownames(tab) %in% positives

		pr <- pr.curve( -log10(tab$P.Value[idx]), -log10(tab$P.Value[!idx]), curve=TRUE, rand.compute=TRUE )

		data.frame( method 		= method, 
					AUPR 		= pr$auc.integral, 
					AUPR.random = pr$rand$auc.integral,
					stringsAsFactors=FALSE)
		})
	res = do.call(rbind, res)

	ord = c('Naive: No controls, no replicates, ignore batch',
			'Simple: No controls, no replicates',
			'Replicates: Two step',
			'Replicates - joint model + noiseToControls',
			'Replicates - joint model',
			'Oracle') 
 
	res$method = factor(res$method, ord)

	res
}

shifter <- function(x, n = 1) {
  if (n == 0) x else c(tail(x, -n), head(x, n))
}
```

```{r simulation.params, fig.width=12, fig.height=4}

opt = list()

opt$n_cases = 100 # total number of individuals
opt$n_control = 10 # number of control individuals
opt$n_time_points = 2
# total number of experiments: N*n_time_points
opt$p = 400
opt$n_de = 0 # genes different between case and control
opt$n_tp = 100 # genes different between time points
opt$n_samples_per_batch = 20
opt$n_batches = opt$n_cases*opt$n_time_points / opt$n_samples_per_batch
opt$n_batches
opt$corrRetain = .8

# n_batches_per_timePoint = n_cases / n_samples_per_batch

opt$distr_ID = estimate_beta_parameters( .3, .01)
opt$distr_Disease = estimate_beta_parameters( .3, .01)
opt$distr_Timepoint = estimate_beta_parameters( .06, .02)
opt$distr_Batch = estimate_beta_parameters( .3, .01)

# distribution of batch probabilites
alpha = 2
opt$prob = sort((1:opt$n_batches)^alpha, decreasing=TRUE)
# opt$prob = c(rep(1/opt$n_batches*2, opt$n_batches/2), rep(0, opt$n_batches/2))


# get names of differentially expressed genes
opt$deGenes = paste0("gene_", sample.int(opt$p, opt$n_de))
opt$tpGenes = paste0("gene_", sample.int(opt$p, opt$n_tp))

```


```{r run.simulation}
info = createInfo( opt )

simObj = generateSimulations( opt, info )

Y_list = evalBatchCorrection( simObj, info )
```

```{r plotStudy, fig.width=15, fig.height=3}
plotStudyDesign( info )
```

```{r canCorPairs, fig.width=5, fig.height=5}
suppressWarnings({
C = canCorPairs(~ Individual + TimePoint + Disease + Batch, info)
})
plotCorrMatrix( C )
```

Confounding score: `r format(C['Batch', 'TimePoint'], digits=3)`

# VariancePartition results
```{r variancePartition, fig.width=12, eval=FALSE}
# fit variancePartition model
vp = fitExtractVarPartModel( simObj$Y, ~ (1|TimePoint) + (1|Disease) + (1|Batch) + (1|Individual), info)
fig1 = plotVarPart( vp ) + ggtitle("Observed data")

# fit variancePartition model on clean data with no batch effect
vp_oracle = fitExtractVarPartModel( simObj$Y_oracle, ~ (1|TimePoint) + (1|Disease) + (1|Batch) + (1|Individual), info)
fig2 = plotVarPart( vp_oracle ) + ggtitle("Oracle")

grid.arrange(fig1, fig2, ncol=2)
```


# PCA using multiple types of corrections
Green points are controls.  Red is case - time point 1, black is case - time point 2.
```{r pca, fig.width=8, fig.height=8}
# Plot coloring by individual
par(mfrow=c(2,2), pty='s')
# PCA of data with no batch effect
dcmp = prcomp( t(simObj$Y_oracle), scale=TRUE)
pct = format(dcmp$sdev[1:2]^2 / sum(dcmp$sdev^2)*100, digits=3)
plot(dcmp$x[,1:2], col=info$Status, pch=as.integer(info$Disease)+6, 
	xlab = paste0('PC1 (', pct[1], '%)'), ylab = paste0('PC2 (', pct[1], '%)'),
	main="Oracle")

# PCA of original data
dcmp = prcomp( t(simObj$Y), scale=TRUE)
pct = format(dcmp$sdev[1:2]^2 / sum(dcmp$sdev^2)*100, digits=3)
plot(dcmp$x[,1:2], col=info$Status, pch=as.integer(info$Disease)+6, 
	xlab = paste0('PC1 (', pct[1], '%)'), ylab = paste0('PC2 (', pct[1], '%)'),
	main="Observed data")

dcmp = prcomp( t(Y_list[["remove_batch_full_model"]]), scale=TRUE)
pct = format(dcmp$sdev[1:2]^2 / sum(dcmp$sdev^2)*100, digits=3)
plot(dcmp$x[,1:2], col=info$Status, pch=as.integer(info$Disease)+6, 
	xlab = paste0('PC1 (', pct[1], '%)'), ylab = paste0('PC2 (', pct[1], '%)'),
	 main="Full model of replicates")

dcmp = prcomp( t(Y_list[["remove_batch_simple"]]), scale=TRUE)
pct = format(dcmp$sdev[1:2]^2 / sum(dcmp$sdev^2)*100, digits=3)
plot(dcmp$x[,1:2], col=info$Status, pch=as.integer(info$Disease)+6, 
	xlab = paste0('PC1 (', pct[1], '%)'), ylab = paste0('PC2 (', pct[1], '%)'),
	main="Simple batch correction")

```

# Performance for single simulation
```{r differential.expression}

fitList = evalDifferentialExpression(simObj, info)

res = evalPerformance( fitList, coef='TimePointtime2', positives = simObj$tpGenes)

ggplot(res, aes(method, AUPR, fill=method)) + geom_bar(stat="identity") + theme_bw() + theme(aspect.ratio=1, plot.title = element_text(hjust = 0.5), legend.position="none") + xlab("Method") + scale_y_continuous(limits=c(0, 1.02), expand=c(0, 0)) + geom_hline(yintercept = res$AUPR.random[1], linetype="dashed") + coord_flip() 

```


# Iterate through simulations
```{r big.sim, eval=FALSE}
opt = list()

opt$n_cases = 100 # total number of individuals
opt$n_control = 10 # number of control individuals
opt$n_time_points = 2
# total number of experiments: N*n_time_points
opt$p = 400
opt$n_de = 0 # genes different between case and control
opt$n_tp = 100 # genes different between time points
opt$n_samples_per_batch = 20
opt$n_batches = opt$n_cases*opt$n_time_points / opt$n_samples_per_batch
opt$n_batches
opt$corrRetain = .9

# n_batches_per_timePoint = n_cases / n_samples_per_batch

opt$distr_ID = estimate_beta_parameters( .3, .01)
opt$distr_Disease = estimate_beta_parameters( .3, .01)
opt$distr_Timepoint = estimate_beta_parameters( .06, .02)
opt$distr_Batch = estimate_beta_parameters( .3, .01)

# distribution of batch probabilites
alpha = 2
opt$prob = sort((1:opt$n_batches)^alpha, decreasing=TRUE)
# opt$prob = c(rep(1/opt$n_batches*2, opt$n_batches/2), rep(0, opt$n_batches/2))

# get names of differentially expressed genes
opt$deGenes = paste0("gene_", sample.int(opt$p, opt$n_de))
opt$tpGenes = paste0("gene_", sample.int(opt$p, opt$n_tp))


info = createInfo( opt )

plotStudyDesign( info )

simObj = generateSimulations( opt, info )

Y_list = evalBatchCorrection( simObj, info )

fitList = evalDifferentialExpression(simObj, info, opt$corrRetain)

res = evalPerformance( fitList, coef='TimePointtime2', positives = opt$tpGenes)




```

