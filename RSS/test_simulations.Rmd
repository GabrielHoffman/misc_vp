---
title: "Linear mixed models with empirical Bayes"
subtitle: ''
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.Date()`"
documentclass: article
output: 
  html_document:
    smart: false
---


<!--- 
# run analysis
cd /Users/gabrielhoffman/workspace/repos/misc_vp/RSS

rmarkdown::render("test_simulations.Rmd")




 ml pandoc git

system("ml git; git pull")

rmarkdown::render("/hpc/users/hoffmg01/scripts/Brennand/COS/evaluate_power.Rmd")
   

    toc: true
--->


```{r load.packages, echo=FALSE, message=FALSE, results='hide', echo=FALSE}
suppressPackageStartupMessages({
library(variancePartition)
library(ggplot2)
library(BiocParallel)
library(lmerTest)
library(knitr)
library(sparsesvd)
library(tidyverse)
library(kableExtra)
library(PRROC)
library(cowplot)
})

data(varPartData)

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=TRUE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE,
  dev = c("png", "pdf"),   fig.width=7, fig.height=7)

options(markdown.HTML.stylesheet = 'css/custom.css')
```


```{r define, echo=FALSE, cache=FALSE}

source("rdf_functions.R")



 # rdf.satterthwaite(fit)

    # linear time approximation
    # follows Hastie and Tibshirani. Generalized Additive Models. 1990
    # p54 for redf
      # p305 for fast approximation


# Compare emprical density if RSS/sigma^2
# mixture of chi-square, 
# and rdf.satterthwaite


# Distribution of RSS is a mixture of chisq weighted by eigen values of (I-H)(I-H).  In linear regression, this simplifies substantially to RSS/sigma^2 ~ \chi^2_{n-p-1}.  This simplication depends on H being idempotent where eigen-values are either 1 or 0.  But the shrinkage in linear mixed models produces eigen-values between 0 and 1.

# Naively computing eigen values of H is O(n^3).  Since only the first k eigen-values are non-zero they can be computed in O(n^2k).  But there is a linear time method too.  Since H = crossprod(A) + crossprod(B) where A and B are both low rank and sparse.  Compute lambda_a and lambda_b fast then then compute lambda.


# mixture of chisq works with 
dmixchisq = function(x, df){

  res = lapply(df, function(dff){
    dchisq(x, dff)
    })
  res = do.call(rbind, res)

  colSums(res) / length(df)
}

#' Scaled chi-square 
#' 
#' Scaled chi-square density using a gamma distribution
dscchisq = function(x, a, b){
  dgamma(x, b/2, 1/(2*a))
}
```

# Mixture of chi-squares
Let $x$ be a weighted mixture of $n$ $\chi^2_1$ values so that $x \sim \sum_{i=1}^n \lambda_i \chi^2_1$.  This distribution has $n$ parameters and an expectation $\sum_{i=1}^n \lambda_i$.  It can be approximated using a single $\chi^2_\nu$ by setting $\nu = \sum_{i=1}^n \lambda_i$.  Here 100000 values were sampled from a weighted mixture of $\chi^2_1$ with $\lambda_i = 0.5$ and the kernel density is plotted in black for multiple values of $n$. The $\chi^2_\nu$ approximation is shown in red for each value of $n$.     

```{r mixture_of_chisq, fig.width=10}
x = seq(0, 30, length.out=1000)

figList = lapply( c(2, 5, 7, 10, 20, 30), function(n){
  # simulate weights
  # lambda = sort(rbeta(n, .5, .5))
  lambda = rep(0.5, n)

  # draw values from mixture of chisq
  value = sapply(1:100000, function(i){
    sum(lambda * rchisq(length(lambda), 1))
    })
  
  df2 = data.frame(x=x, density = dchisq(x, sum(lambda)))
  df2 = df2[df2$density > 1e-3,]

  ggplot(data.frame(value = value), aes(value)) + geom_density() + theme_classic() + theme(plot.title = element_text(hjust = 0.5), aspect.ratio=1)  + geom_line(data=df2, aes(x, density), color='red', linetype="dashed") + ggtitle(paste0('n=',n)) + scale_y_continuous(expand=c(0,0), limits=c(0, NA)) + scale_x_continuous(expand=c(0,0), limits=c(0, NA))
})

plot_grid( plotlist = figList, ncol=3)
```

# Run simulatuions
```{r simulate.data}
set.seed(1)
# info = rbind(info, info, info)
lvl = levels(info$Individual)
info = droplevels(info[info$Individual %in% lvl[1:4],])
n_genes = 20000
var_true = rgamma(n_genes, 5, 1)
# var_true[] = 10

n_de = n_genes/2

geneExpr = lapply(1:n_genes, function(j){

  b = ifelse(j <= n_de, .4, 0)

  beta_Tissue = rnorm(nlevels(info$Tissue))
  beta_ID = rnorm(nlevels(info$Individual))
  beta_Batch = rnorm(nlevels(info$Batch))

  y = model.matrix(~0+Age, info) * b +
    model.matrix(~0+Individual, info) %*% beta_ID +   
    model.matrix(~0+Tissue, info) %*% beta_Tissue + 
    model.matrix(~0+Batch, info) %*% beta_Batch +
    rnorm(nrow(info), 0, sd=sqrt(var_true[j])) 
  t(y)
  })
geneExpr = do.call(rbind, geneExpr)
rownames(geneExpr) = paste0('gene_', 1:nrow(geneExpr))

# Fit models
form = ~ Age + (1|Individual) + (1|Tissue) + (1|Batch)
# form = ~ (1|Individual)

# fixed effects
dsgn = model.matrix(subbars(form), info)
fit_lm = lmFit( geneExpr, dsgn)

REML = TRUE
# linear mixed model
fit_mm = dream( geneExpr, form, info, BPPARAM=SnowParam(6), REML=REML)

# define RDF for LMM
res = fitVarPartModel( geneExpr, form, info, fxn = rdf.merMod, REML=REML, BPPARAM=SerialParam() )

# df.values = sapply(res, function(x) x$df)
df.values = unlist(res)
df.residual.orig = fit_mm$df.residual 
fit_mm$df.residual = df.values

# rdf.shape = sapply(res, function(x) x$shape)
# rdf.scale = sapply(res, function(x) x$scale)
```

# Residual degrees of freedom

```{r plot.fixed, fig.height=4, fig.width=9}
# Fixed effect model
# fit$sigma^2 is already corrected by n-1
rdf = nrow(info) - ncol(fit_lm$design)
RSS = apply(residuals(fit_lm, geneExpr), 1, function(x) sum(x^2))

ggtheme = theme_bw(16) + theme(plot.title = element_text(hjust = 0.5), aspect.ratio=1) 

df = data.frame(value = RSS/var_true)
x = seq(0, max(df$value), length.out=10000)
df2 = data.frame(x=x, value = dchisq(x, df=rdf))

fig_fixed = ggplot(df, aes(value)) + geom_density() + ggtheme + xlim(0, NA) + ggtitle("Linear model") + geom_line(data=df2, aes(x, value), color="red") + xlab(bquote(RSS/sigma^2))

## Mixed model
n = nrow(info)
RSS = apply(fit_mm$residuals, 1, function(x) sum(x^2))

df = data.frame(value = RSS/var_true)
x = seq(0, max(df$value), length.out=10000)
df2 = data.frame(x=x, value = dmixchisq(x, df=fit_mm$df.residual ))

fig_mixed = ggplot(df, aes(value)) + geom_density() + ggtheme + xlim(0, NA) + ggtitle("Linear mixed model") + geom_line(data=df2, aes(x, value), color="red") + xlab(bquote(RSS/sigma^2)) 

plot_grid( fig_fixed, fig_mixed)
```

## Residual degrees of freedom run time
```{r rdf.time, message=FALSE}
data(varPartData)
infoCombine = rbind(info, info, info)
infoCombine = rbind(infoCombine, infoCombine)

lvl = levels(infoCombine$Individual)

n_reps = 20

df_time = lapply(2:25, function(k){

  message("\rk = ",k)
  infoSub = droplevels(infoCombine[infoCombine$Individual %in% lvl[1:k],])

  beta_Tissue = rnorm(nlevels(infoSub$Tissue))
  beta_ID = rnorm(nlevels(infoSub$Individual))
  beta_Batch = rnorm(nlevels(infoSub$Batch))

  y = model.matrix(~0+Age, infoSub) * 1.0 +
    model.matrix(~0+Individual, infoSub) %*% beta_ID +   
    model.matrix(~0+Tissue, infoSub) %*% beta_Tissue + 
    model.matrix(~0+Batch, infoSub) %*% beta_Batch +
    rnorm(nrow(infoSub), 0, sd=1) 
 
  fit = lmer(y ~ Age + (1|Batch) + (1|Tissue) + (1|Individual), infoSub)    

  data.frame(N          = nrow(infoSub), 
            rdf.merMod  = system.time(replicate(n_reps, rdf.merMod(fit)))[3],
            rdf.naive   = system.time(replicate(n_reps, rdf.merMod(fit, "quadratic")))[3])
})
df_time = do.call(rbind, df_time)

df_melt = reshape2::melt(df_time, id.vars='N')
df_melt$variable = factor(df_melt$variable, c('rdf.naive', 'rdf.merMod'))

xmax = max(df_melt$N) * 1.05
ymax = max(df_melt$value / n_reps * 20000) * 1.05
ggplot(df_melt, aes(N, value / n_reps * 20000, color=variable)) + geom_point() + theme_classic() + theme(plot.title = element_text(hjust = 0.5), aspect.ratio=1) + geom_smooth(formula = y ~ x + I(x^2), method="lm", se=FALSE) + ylab("Time (seconds for 20K genes)") + scale_color_manual(name = "Method", values=c('red2', 'dodgerblue')) + scale_x_continuous(expand=c(0, 0), limits=c(0, xmax)) + scale_y_continuous(expand=c(0, 0), limits=c(0, ymax)) + xlab("Sample size")
```


```{r test, eval=FALSE}
# estimate sigma
fit@devcomp$cmp['sigmaML']
sqrt(fit@devcomp$cmp['pwrss'] / fit@devcomp$dim['n'])
sqrt(fit@devcomp$cmp['pwrss'] / rdf.approx(fit))

f = function(fit){
  # sqrt(fit@devcomp$cmp['pwrss'] / rdf.approx(fit))
  fit@devcomp$cmp['wrss']
}

res2.RSS = fitVarPartModel( geneExpr, form, info, fxn = f, REML=REML, BPPARAM=SnowParam(6) )
RSS = unlist(res2.RSS)

i = 1:length(RSS)
df = data.frame(value = RSS[i]/var_true[i])
x = seq(0, max(df$value), length.out=10000)
df2 = data.frame(x=x, value = dmixchisq(x, df=fit_mm$df.residual[i] ))

ggplot(df, aes(value)) + geom_density() + ggtheme + xlim(0, NA) + ggtitle("Mixed effect RSS /  true variance") + geom_line(data=df2, aes(x, value), color="red") + xlab(bquote(RSS/sigma^2)) + xlim(200, 350)


f = function(fit){
  # sqrt(fit@devcomp$cmp['pwrss'] / rdf.approx(fit))
  # fit@devcomp$cmp['pwrss']
  sigma(fit)^2 *  fit@devcomp$dims['nmp']
}

res2.RSS.p = fitVarPartModel( geneExpr, form, info, fxn = f, REML=REML, BPPARAM=SnowParam(6) )
RSS.p = unlist(res2.RSS.p)

i = 1:length(RSS)
df = data.frame(value = RSS.p[i]/var_true[i])
x = seq(0, max(c(max(df$value), max(fit_mm$df.residual[i])*1.5)), length.out=10000)
df2 = data.frame(x=x, value = dmixchisq(x, df=fit_mm$df.residual[i] ))

ggplot(df, aes(value)) + geom_density() + ggtheme + xlim(0, NA) + ggtitle("Mixed effect RSS /  true variance") + geom_line(data=df2, aes(x, value), color="red") + xlab(bquote(RSS/sigma^2)) 
```

```{r est.sigma, fig.width=8, fig.height=20}
# Create fit_mm_mod which is like fit_mm except sigma is estimated as RSS/rdf
fit_mm_mod = fit_mm
RSS = apply(fit_mm$residuals, 1, function(x) sum(x^2))
sigSqm = RSS / fit_mm$df.residual 
fit_mm_mod$sigma = sqrt(sigSqm)


# apply Emprical Bayes 
fit_eb = limma::eBayes(fit_lm)
fit_eb_mm = limma::eBayes(fit_mm)
fit_eb_mm_mod = limma::eBayes(fit_mm_mod)

# Empirical Bayes results
fit_eb$df.prior
fit_eb_mm$df.prior
fit_eb_mm_mod$df.prior

fit_eb$s2.prior
fit_eb_mm$s2.prior
fit_eb_mm_mod$s2.prior



df = data.frame(value = fit_mm$df.residual)
fig_rdf = ggplot(df, aes(value)) + geom_density() + ggtheme + xlab("Residual degrees of freedom")

# variances from linear model
fig_fixed = plot_variance_estimates(fit_lm, fit_eb, var_true)

# variances from linear mixed model
fig_mixed = plot_variance_estimates(fit_mm, fit_eb_mm_mod, var_true)

df_mse = data.frame(sigSq = mean((fit_lm$sigma^2 - var_true)^2),
          sigSq_mm = mean((fit_mm$sigma^2 - var_true)^2),
          sigSq_post = mean((fit_eb$s2.post - var_true)^2),
          sigSq_mm_post = mean((fit_eb_mm$s2.post - var_true)^2), 
          sigSq_mm_mod_post = mean((fit_eb_mm_mod$s2.post - var_true)^2))

df = reshape2::melt(df_mse)
df$variable = factor(df$variable, rev(levels(df$variable)))

ymax = max(df$value)*1.05
fig_MSE = ggplot(df, aes(variable, value)) + geom_bar(stat="identity") + ggtheme + ylab("Mean squared error") + scale_y_continuous(expand=c(0, 0), limits=c(0, ymax)) + coord_flip()

plot_grid( fig_rdf, fig_fixed, fig_mixed, fig_MSE, ncol=1)



df = data.frame(LM = fit_lm$sigma^2, EB = fit_eb$s2.post)
lim = max(c(max(df$LM), max(df$EB)))
fig_shrink_fixed = ggplot(df, aes(LM, EB)) + geom_point() + ggtheme + geom_abline(color="red") + xlim(0, lim) + ylim(0, lim) + geom_smooth(method="lm") + ggtitle("Fixed effect model")

lm(fit_eb$s2.post ~ fit_lm$sigma^2)

df = data.frame(MM = fit_mm$sigma^2, EB = fit_eb_mm_mod$s2.post)
lim = max(c(max(df$MM), max(df$EB)))
fig_shrink_mixed = ggplot(df, aes(MM, EB)) + geom_point() + ggtheme + geom_abline(color="red") + xlim(0, lim) + ylim(0, lim) + geom_smooth(method="lm") + ggtitle("Mixed effect model")

plot_grid(fig_shrink_fixed, fig_shrink_mixed)

# kable(df_mse, digits=3) %>% kable_styling(full_width = FALSE)


shrinkageMetric( fit_lm$sigma^2, fit_eb$s2.post )

shrinkageMetric( fit_mm$sigma^2, fit_eb_mm_mod$s2.post )

```

```{r ebayes.test}

# original
# out$t <- coefficients / stdev.unscaled / sqrt(out$s2.post)
# df.total <- df.residual + out$df.prior
# df.pooled <- sum(df.residual,na.rm=TRUE)
# df.total <- pmin(df.total,df.pooled)
# out$df.total <- df.total
# out$p.value <- 2*pt(-abs(out$t),df=df.total)

eb = function(fiteb, df, coef){

  df.test = df[,coef]
  df.total <- df.test + fiteb$df.prior

  tstat = with(fiteb, coefficients / stdev.unscaled / sqrt(s2.post))
  p.value = 2*pt(-abs(tstat[,coef]),df=df.total )
  p.value
}

de_oracle = function(fit, df, coef, var_true){

  df.test = df[,coef]
  tstat = with(fit, coefficients / stdev.unscaled / sqrt(var_true))
  p.value = 2*pt(-abs(tstat[,coef]),df=df.test )
  p.value
}


```

```{r aupr, eval=TRUE}

true_de = rep(0, n_genes)
true_de[1:n_de] = 1

coef = "Age"
p.fit_eb = topTable(fit_eb, coef, number=Inf, sort.by="none")[,'P.Value']
pr = pr.curve( -log10(p.fit_eb), true_de, curve=TRUE )
pr$auc.integral

p.fit_mm = topTable(fit_mm, coef, number=Inf, sort.by="none")[,'P.Value']
pr = pr.curve( -log10(p.fit_mm), true_de, curve=TRUE )
pr$auc.integral


p.fit_eb_mm_mod = topTable(fit_eb_mm_mod, coef, number=Inf, sort.by="none")[,'P.Value']
pr = pr.curve( -log10(p.fit_eb_mm_mod), true_de, curve=TRUE )
pr$auc.integral

p.mm.eb = eb( fit_eb_mm_mod, df.residual.orig, coef)
pr = pr.curve( -log10(p.mm.eb), true_de, curve=TRUE )
pr$auc.integral


p.oracle = de_oracle(fit_eb_mm_mod, df.residual.orig, coef, var_true)
pr = pr.curve( -log10(p.oracle), true_de, curve=TRUE )
pr$auc.integral


sum(p.fit_eb[true_de==0] < 0.05) / sum(true_de==0)
sum(p.fit_mm[true_de==0] < 0.05) / sum(true_de==0)
sum(p.fit_eb_mm_mod[true_de==0] < 0.05) / sum(true_de==0)
sum(p.mm.eb[true_de==0] < 0.05) / sum(true_de==0)
sum(p.oracle[true_de==0] < 0.05) / sum(true_de==0)



# plot(-log10(p.oracle), -log10(p))


```




```{r fpr}
fit_eb$df.total[1:3]
fit_eb_mm$df.total[1:3]

coef = "(Intercept)"
p = topTable(fit_eb, coef, number=Inf, sort.by="none")[,'P.Value']
sum(p < 0.05) / length(p)


p = topTable(fit_mm, coef, number=Inf, sort.by="none")[,'P.Value']
sum(p < 0.05) / length(p)

p = topTable(fit_eb_mm, coef, number=Inf, sort.by="none")[,'P.Value']
sum(p < 0.05) / length(p)

p.new = 2*pt(abs(fit_eb_mm$t[,coef]), df=df.residual.orig[,coef] + fit_eb_mm$df.prior, lower.tail=FALSE)
sum(p.new < 0.05) / length(p.new)


p.new = 2*pt(abs(fit_eb_mm$t[,coef]), df=df.residual.orig[,coef], lower.tail=FALSE)
sum(p.new < 0.05) / length(p.new)


p.new = 2*pt(abs(fit_eb_mm_mod$t[,coef]), df=df.residual.orig[,coef] + fit_eb_mm_mod$df.prior, lower.tail=FALSE)
sum(p.new < 0.05) / length(p.new)
```


Since fit_mm$sigma^2 must be recomputed from RSS and rdf, how is it used in topTable?
